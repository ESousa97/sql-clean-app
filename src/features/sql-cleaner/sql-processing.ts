import { DEFAULT_CHUNK_SIZE } from './constants';
import type {
  CopyDataBlock,
  DataSection,
  ParsedDump,
  ProcessingSection,
} from './types';

function cleanMarkdown(code: string): string {
  return code.replace(/```sql\n?/gi, '').replace(/```\n?/g, '').trim();
}

export function parseSqlDump(content: string): ParsedDump {
  const lines = content.split('\n');
  const structureLines: string[] = [];
  const dataBlocks: CopyDataBlock[] = [];

  let currentCopyBlock: CopyDataBlock | null = null;

  for (const line of lines) {
    const trimmedLine = line.trim();

    if (trimmedLine.startsWith('COPY ') && trimmedLine.includes('FROM stdin;')) {
      const copyMatch = trimmedLine.match(/COPY\s+(\w+\.\w+)\s+\(([^)]+)\)\s+FROM\s+stdin;/);
      if (copyMatch) {
        currentCopyBlock = {
          tableName: copyMatch[1],
          columns: copyMatch[2],
          data: [],
        };
      }
      continue;
    }

    if (currentCopyBlock) {
      if (trimmedLine === '\\.') {
        if (currentCopyBlock.data.length > 0) {
          dataBlocks.push(currentCopyBlock);
        }
        currentCopyBlock = null;
      } else if (trimmedLine && !trimmedLine.startsWith('--')) {
        currentCopyBlock.data.push(line);
      }
      continue;
    }

    if (
      trimmedLine.startsWith('\\connect') ||
      trimmedLine.startsWith('\\c ') ||
      trimmedLine.startsWith('\\') ||
      trimmedLine.startsWith('INSERT INTO')
    ) {
      continue;
    }

    structureLines.push(line);
  }

  if (currentCopyBlock && currentCopyBlock.data.length > 0) {
    dataBlocks.push(currentCopyBlock);
  }

  return { structureLines, dataBlocks };
}

export function createDataSections(
  dataBlocks: CopyDataBlock[],
  chunkSize = DEFAULT_CHUNK_SIZE,
): DataSection[] {
  const sections: DataSection[] = [];

  for (const { tableName, columns, data } of dataBlocks) {
    const totalChunks = Math.ceil(data.length / chunkSize);

    for (let index = 0; index < totalChunks; index += 1) {
      const startIndex = index * chunkSize;
      const endIndex = Math.min(startIndex + chunkSize, data.length);
      const chunkData = data.slice(startIndex, endIndex);

      const content = [
        `COPY ${tableName} (${columns}) FROM stdin;`,
        ...chunkData,
        '\\.',
      ].join('\n');

      sections.push({
        type: 'data',
        content,
        priority: 7,
        tableName,
        chunkIndex: index + 1,
        totalChunks,
        recordCount: chunkData.length,
      });
    }
  }

  return sections;
}

export function normalizeValuesBlock(raw: string): string[] {
  let content = cleanMarkdown(raw);

  const valuesIndex = content.toUpperCase().indexOf('VALUES');
  if (valuesIndex >= 0) {
    content = content.slice(valuesIndex + 'VALUES'.length);
  }

  return content
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line.startsWith('('))
    .map((line) => line.replace(/[,;]\s*$/, ''));
}

export function buildFinalSql(params: {
  fileName: string;
  structureSections: ProcessingSection[];
  valuesByTable: Record<string, string[]>;
  dataBlocks: CopyDataBlock[];
  processedSections: number;
  successfulSections: number;
  failedSections: number;
}): string {
  const {
    fileName,
    structureSections,
    valuesByTable,
    dataBlocks,
    processedSections,
    successfulSections,
    failedSections,
  } = params;

  const lines: string[] = [
    '-- PostgreSQL Database Restore (Cleaned and Organized)',
    '-- Generated by SQL Cleaner',
    '-- All COPY blocks converted to INSERT statements',
    `-- Original file: ${fileName}`,
    `-- Processed sections: ${processedSections}`,
    `-- Successful conversions: ${successfulSections}`,
    `-- Failed sections (kept original): ${failedSections}`,
    `-- Tables with data: ${Object.keys(valuesByTable).length}`,
    '',
  ];

  const structureContent = structureSections
    .map((section) => section.content)
    .join('\n')
    .trim();

  if (structureContent) {
    lines.push('-- DATABASE STRUCTURE');
    lines.push(structureContent);
    lines.push('');
  }

  if (Object.keys(valuesByTable).length > 0) {
    lines.push('-- DATA SECTION');

    const firstBlockByTable = new Map<string, CopyDataBlock>();
    for (const block of dataBlocks) {
      if (!firstBlockByTable.has(block.tableName)) {
        firstBlockByTable.set(block.tableName, block);
      }
    }

    for (const [tableName, values] of Object.entries(valuesByTable)) {
      const firstBlock = firstBlockByTable.get(tableName);
      if (!firstBlock || values.length === 0) {
        continue;
      }

      lines.push(`-- Data for table: ${tableName}`);
      lines.push(`INSERT INTO ${tableName} (${firstBlock.columns}) VALUES`);

      values.forEach((value, index) => {
        const suffix = index === values.length - 1 ? ';' : ',';
        lines.push(`${value}${suffix}`);
      });

      lines.push('');
    }
  }

  return lines.join('\n');
}
